#!/usr/bin/env python3
"""
make_8x8_from_ttf_full.py

Scan a TTF for all Unicode codepoints it supports, rasterize each glyph
into an 8×8 bitmap (1-bit), then emit a JavaScript file exporting a
lookup of codepoint→[8‐byte bitmap].

Usage:
    python make_8x8_from_ttf_full.py /path/to/myfont.ttf output.js

After running, `output.js` will look like:

    export const font8x8_from_ttf = {
      0x0020: [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],  // ' '
      0x0021: [0x00,0x18,0x18,0x18,0x18,0x00,0x18,0x00],  // '!'
      0x0022: [0x6C,0x6C,0x24,0x00,0x00,0x00,0x00,0x00],  // '"'
      ...
      0x00C7: [0x00,0x3C,0x42,0x80,0x80,0x42,0x3C,0x00],  // 'Ç'
      ...
      // etc., for all 915 glyphs the font actually contains
    };
"""

import sys
import os
from PIL import Image, ImageDraw, ImageFont
from fontTools.ttLib import TTFont

def collect_codepoints_from_ttf(ttf_path):
    """
    Use fontTools to read the 'cmap' table of the TTF and return
    a sorted list of all Unicode codepoints for which the font has a glyph.
    """
    tt = TTFont(ttf_path)
    codepoints = set()

    # Iterate over all sub‐tables in the 'cmap' table
    for table in tt["cmap"].tables:
        # table.cmap is a dict: codepoint→glyphName
        for cp in table.cmap.keys():
            codepoints.add(cp)

    tt.close()
    return sorted(codepoints)

def render_to_8x8(font, cp):
    """
    Given a PIL ImageFont (at pixel‐size 8) and a Unicode codepoint cp,
    render it into an 8×8 grayscale image, threshold to 1‐bit, and return
    a list of 8 integers (each 0..255) representing one row of bits.
    If the font truly does not have this glyph (rare, since we only called
    this on codepoints collected from cmap), we return [0]*8.
    """
    # 1) Create an 8×8 grayscale canvas (mode "L"), black=0
    img = Image.new("L", (8, 8), 0)
    draw = ImageDraw.Draw(img)

    char = chr(cp)

    # 2) Check whether this glyph actually draws anything.
    #    getbbox returns None if the glyph is missing or empty.
    try:
        bbox = font.getbbox(char)
    except Exception:
        bbox = None

    if not bbox:
        # Missing or empty glyph → return blank
        return [0x00] * 8

    x0, y0, x1, y1 = bbox
    w = x1 - x0
    h = y1 - y0
    if w == 0 or h == 0:
        # Degenerate → treat as blank
        return [0x00] * 8

    # 3) Center the glyph inside the 8×8 box.
    #    We want to draw the glyph so its bounding box (w×h) is roughly centered.
    dx = (8 - w) // 2 - x0
    dy = (8 - h) // 2 - y0

    # Draw it in white (255)
    draw.text((dx, dy), char, font=font, fill=255)

    # 4) Threshold to 1‐bit. Leftmost pixel is bit 7, rightmost is bit 0.
    rows = []
    for y in range(8):
        row_byte = 0
        for x in range(8):
            val = img.getpixel((x, y))
            if val > 128:
                row_byte |= (1 << (7 - x))
        rows.append(row_byte & 0xFF)

    return rows

def generate_all_bitmaps(ttf_path, px_size=8):
    """
    1) Load the TTF at pixel‐size = px_size.
    2) Enumerate all codepoints via fontTools.
    3) For each codepoint, render into 8×8, threshold, collect 8‐byte list.
    Return a dict: codepoint → [byte0, …, byte7].
    """
    # 1) Load PIL ImageFont
    pil_font = ImageFont.truetype(ttf_path, px_size)

    # 2) Collect all Unicode codepoints present in the font
    cps = collect_codepoints_from_ttf(ttf_path)

    # 3) Render each to 8×8
    table = {}
    for cp in cps:
        table[cp] = render_to_8x8(pil_font, cp)

    return table

def dump_js_lookup(bitmap_table, output_path):
    """
    Given a dict `bitmap_table` mapping codepoint→8‐byte list,
    write out a JavaScript module exporting a single object:
       export const font8x8_from_ttf = {
         0x0020: [ … ],
         0x0021: [ … ],
         // …
       };
    """
    with open(output_path, "w", encoding="utf-8") as f:
        f.write("// Auto‐generated by make_8x8_from_ttf_full.py\n")
        f.write("// Contains " + str(len(bitmap_table)) + " glyphs\n\n")
        f.write("export const font8x8_petscii = {\n")

        for cp in sorted(bitmap_table.keys()):
            rows = bitmap_table[cp]
            hex_bytes = ",".join(f"0x{b:02X}" for b in rows)

            # Comment: if printable ASCII, show the character; else show hex only
            if 0x20 <= cp <= 0x7E:
                comment = f" // '{chr(cp)}' (U+{cp:04X})"
            else:
                comment = f" // U+{cp:04X}"

            f.write(f"  0x{cp:04X}: [{hex_bytes}],{comment}\n")

        f.write("};\n")

def main():
    if len(sys.argv) != 3:
        print("Usage: python make_8x8_from_ttf_full.py /path/to/font.ttf output.js")
        sys.exit(1)

    ttf_path = sys.argv[1]
    output_js = sys.argv[2]

    if not os.path.isfile(ttf_path):
        print(f"Error: TTF file not found: {ttf_path}")
        sys.exit(1)

    print("Scanning TTF for Unicode codepoints…")
    table = generate_all_bitmaps(ttf_path, px_size=8)
    print(f"Found {len(table)} codepoints/glyphs; rendering and writing to {output_js}…")
    dump_js_lookup(table, output_js)
    print("Done.")

if __name__ == "__main__":
    main()